# coding=utf-8
# Copyright 2020 The HuggingFace Inc. team
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Beam constraint classes for constrained beam search.

These classes were removed from transformers 5.x and are provided here
for backward compatibility with the project's beam search implementation.
"""

from abc import ABC, abstractmethod
from typing import List, Optional


class Constraint(ABC):
    """
    Abstract base class for all constraints that can be applied during constrained beam search.

    This class defines the interface that all constraints must implement to be used with
    `ConstrainedBeamSearchScorer`.
    """

    def __init__(self):
        # The tokens that must be generated by the end of the beam search
        self.sequences: List[List[int]] = []
        # The current state of the constraint
        self.current_seq: List[int] = []
        self.completed: bool = False

    @abstractmethod
    def advance(self) -> List[int]:
        """
        Returns the list of tokens that would advance the constraint.

        Returns:
            List[int]: The list of token ids that would advance the constraint.
        """
        raise NotImplementedError

    @abstractmethod
    def does_advance(self, token_id: int) -> bool:
        """
        Returns whether the given token would advance the constraint.

        Args:
            token_id (int): The token id to check.

        Returns:
            bool: Whether the token would advance the constraint.
        """
        raise NotImplementedError

    @abstractmethod
    def reset(self, sequence: List[int]) -> None:
        """
        Resets the constraint state given a sequence.

        Args:
            sequence (List[int]): The sequence to reset the constraint state to.
        """
        raise NotImplementedError

    @abstractmethod
    def copy(self, stateful: bool = False) -> "Constraint":
        """
        Creates a copy of the constraint.

        Args:
            stateful (bool, optional): Whether to copy the stateful information. Defaults to False.

        Returns:
            Constraint: A copy of the constraint.
        """
        raise NotImplementedError

    def __repr__(self):
        return f"{self.__class__.__name__}(sequences={self.sequences}, completed={self.completed})"


class PhrasalConstraint(Constraint):
    """
    A constraint that requires a specific phrase to be present in the generated sequence.

    Args:
        token_ids (List[int]): The token ids that must be present in the generated sequence.
    """

    def __init__(self, token_ids: List[int]):
        super().__init__()
        if not isinstance(token_ids, list) or len(token_ids) == 0:
            raise ValueError("token_ids must be a non-empty list of integers")
        if any(not isinstance(token_id, int) or token_id < 0 for token_id in token_ids):
            raise ValueError("token_ids must be a list of non-negative integers")
        self.token_ids = token_ids
        self.sequences = [token_ids]
        self.current_seq = []
        self.completed = False
        self._pos = 0

    def advance(self) -> List[int]:
        """Returns the next token that would advance the constraint."""
        if self.completed:
            return []
        return [self.token_ids[self._pos]]

    def does_advance(self, token_id: int) -> bool:
        """Returns whether the given token would advance the constraint."""
        if self.completed:
            return False
        return token_id == self.token_ids[self._pos]

    def reset(self, sequence: List[int]) -> None:
        """Resets the constraint state given a sequence."""
        self.current_seq = sequence.copy()
        self.completed = False
        self._pos = 0

        # Check if the sequence ends with a prefix of our token_ids
        for i in range(len(sequence)):
            # Try to match starting from position i
            remaining = sequence[i:]
            if len(remaining) <= len(self.token_ids):
                if remaining == self.token_ids[: len(remaining)]:
                    self._pos = len(remaining)
                    if self._pos == len(self.token_ids):
                        self.completed = True
                    return

        # Check if the full phrase is already in the sequence
        phrase_len = len(self.token_ids)
        if len(sequence) >= phrase_len:
            for i in range(len(sequence) - phrase_len + 1):
                if sequence[i : i + phrase_len] == self.token_ids:
                    self.completed = True
                    self._pos = phrase_len
                    return

    def copy(self, stateful: bool = False) -> "PhrasalConstraint":
        """Creates a copy of the constraint."""
        new_constraint = PhrasalConstraint(self.token_ids.copy())
        if stateful:
            new_constraint.current_seq = self.current_seq.copy()
            new_constraint.completed = self.completed
            new_constraint._pos = self._pos
        return new_constraint

    def __repr__(self):
        return f"PhrasalConstraint(token_ids={self.token_ids}, completed={self.completed}, pos={self._pos})"


class DisjunctiveConstraint(Constraint):
    """
    A constraint that requires at least one of several phrases to be present in the generated sequence.

    Args:
        token_ids (List[List[int]]): A list of token id sequences, at least one of which must be
            present in the generated sequence.
    """

    def __init__(self, token_ids: List[List[int]]):
        super().__init__()
        if not isinstance(token_ids, list) or len(token_ids) == 0:
            raise ValueError("token_ids must be a non-empty list of token id lists")

        # Validate each sequence
        for seq in token_ids:
            if not isinstance(seq, list) or len(seq) == 0:
                raise ValueError("Each token id sequence must be a non-empty list")
            if any(not isinstance(token_id, int) or token_id < 0 for token_id in seq):
                raise ValueError("Each token id must be a non-negative integer")

        self.token_ids = token_ids
        self.sequences = token_ids
        self.current_seq = []
        self.completed = False
        # Track position in each possible sequence
        self._positions = [0 for _ in token_ids]

    def advance(self) -> List[int]:
        """Returns the list of tokens that would advance any of the possible sequences."""
        if self.completed:
            return []

        # Return all possible next tokens from sequences that can still advance
        tokens = []
        for i, seq in enumerate(self.token_ids):
            if self._positions[i] < len(seq):
                token = seq[self._positions[i]]
                if token not in tokens:
                    tokens.append(token)
        return tokens

    def does_advance(self, token_id: int) -> bool:
        """Returns whether the given token would advance any of the possible sequences."""
        if self.completed:
            return False

        for i, seq in enumerate(self.token_ids):
            if self._positions[i] < len(seq) and seq[self._positions[i]] == token_id:
                return True
        return False

    def reset(self, sequence: List[int]) -> None:
        """Resets the constraint state given a sequence."""
        self.current_seq = sequence.copy()
        self.completed = False
        self._positions = [0 for _ in self.token_ids]

        # Check each possible sequence
        for seq_idx, seq in enumerate(self.token_ids):
            phrase_len = len(seq)

            # Check if the full phrase is in the sequence
            if len(sequence) >= phrase_len:
                for i in range(len(sequence) - phrase_len + 1):
                    if sequence[i : i + phrase_len] == seq:
                        self.completed = True
                        self._positions[seq_idx] = phrase_len
                        return

            # Check for partial matches at the end
            for i in range(len(sequence)):
                remaining = sequence[i:]
                if len(remaining) <= phrase_len:
                    if remaining == seq[: len(remaining)]:
                        self._positions[seq_idx] = len(remaining)
                        if self._positions[seq_idx] == phrase_len:
                            self.completed = True
                        return

    def copy(self, stateful: bool = False) -> "DisjunctiveConstraint":
        """Creates a copy of the constraint."""
        new_constraint = DisjunctiveConstraint([seq.copy() for seq in self.token_ids])
        if stateful:
            new_constraint.current_seq = self.current_seq.copy()
            new_constraint.completed = self.completed
            new_constraint._positions = self._positions.copy()
        return new_constraint

    def __repr__(self):
        return f"DisjunctiveConstraint(token_ids={self.token_ids}, completed={self.completed}, positions={self._positions})"


class ConstraintListState:
    """
    A class to manage the state of multiple constraints during beam search.

    This class keeps track of the state of multiple constraints and provides
    methods to advance, reset, and check completion of all constraints.

    Args:
        constraints (List[Constraint]): A list of constraints to manage.
    """

    def __init__(self, constraints: List[Constraint]):
        self.constraints = constraints
        self.current_seq: List[int] = []
        self.completed = all(constraint.completed for constraint in self.constraints)

    def reset(self, sequence: List[int]) -> None:
        """
        Resets all constraints given a sequence.

        Args:
            sequence (List[int]): The sequence to reset the constraint states to.
        """
        self.current_seq = sequence.copy()
        for constraint in self.constraints:
            constraint.reset(sequence)
        self.completed = all(constraint.completed for constraint in self.constraints)

    def advance(self) -> List[int]:
        """
        Returns the list of tokens that would advance at least one constraint.

        Returns:
            List[int]: The list of token ids that would advance at least one constraint.
        """
        tokens = []
        for constraint in self.constraints:
            if not constraint.completed:
                for token in constraint.advance():
                    if token not in tokens:
                        tokens.append(token)
        return tokens

    def does_advance(self, token_id: int) -> bool:
        """
        Returns whether the given token would advance at least one constraint.

        Args:
            token_id (int): The token id to check.

        Returns:
            bool: Whether the token would advance at least one constraint.
        """
        for constraint in self.constraints:
            if not constraint.completed and constraint.does_advance(token_id):
                return True
        return False

    def step(self, token_id: int) -> None:
        """
        Advances all constraints with the given token.

        Args:
            token_id (int): The token id to advance with.
        """
        self.current_seq.append(token_id)
        for constraint in self.constraints:
            if not constraint.completed and constraint.does_advance(token_id):
                constraint.reset(self.current_seq)
        self.completed = all(constraint.completed for constraint in self.constraints)

    def copy(self, stateful: bool = False) -> "ConstraintListState":
        """
        Creates a copy of the constraint list state.

        Args:
            stateful (bool, optional): Whether to copy the stateful information. Defaults to False.

        Returns:
            ConstraintListState: A copy of the constraint list state.
        """
        new_constraints = [
            constraint.copy(stateful=stateful) for constraint in self.constraints
        ]
        new_state = ConstraintListState(new_constraints)
        if stateful:
            new_state.current_seq = self.current_seq.copy()
            new_state.completed = self.completed
        return new_state

    def __repr__(self):
        return f"ConstraintListState(constraints={self.constraints}, completed={self.completed})"
